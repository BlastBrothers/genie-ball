//NES recreation of the Game & Watch game "Ball"
//Blast_Brothers 2025
//for the Game Genie Game Jam 
//https://forums.nesdev.org/viewtopic.php?t=26222

data /rlz //compressed data block
    [] main_tilemap
        file(rlz, "tilemap.bin") //the initial background tilemap

ct U[25] main_palette = U[25](
    $3D, $3D, $0F, //BG
    $3D, $3D, $11,
    $3D, $3D, $00,
    $3D, $3D, $29,

    $3D, $3D, $0F, //sprites
    $3D, $3D, $16,
    $3D, $3D, $11,
    $3D, $3D, $1A,

    $3D //Backdrop color
)

//for drawing the score to the screen

struct ScoreDigit
    U tile1 //six separate vars to get around prohibition on nested arrays
    U tile2 //Drawn to screen like this:
    U tile3 // 1 2
    U tile4 // 3 4
    U tile5 // 5 6
    U tile6

ct ScoreDigit[11] digits_tiles = ScoreDigit[11](
    ScoreDigit($A, $E, $A, $A, $8, $C), //0
    ScoreDigit($0, $A, $0, $A, $0, $8), //1
    ScoreDigit($8, $E, $A, $C, $8, $C), //2
    ScoreDigit($8, $E, $0, $E, $8, $C), //3
    ScoreDigit($A, $A, $8, $E, $0, $8), //4
    ScoreDigit($A, $C, $8, $E, $8, $C), //5
    ScoreDigit($A, $C, $A, $E, $8, $C), //6
    ScoreDigit($8, $E, $0, $A, $0, $8), //7
    ScoreDigit($A, $E, $A, $E, $8, $C), //8
    ScoreDigit($A, $E, $8, $E, $8, $C), //9
    ScoreDigit($0, $0, $0, $0, $0, $0)  //Blank
)

ct U GAME_STATE_IDLE = 0
ct U GAME_STATE_GAMEA = 1
ct U GAME_STATE_GAMEB = 2
ct U GAME_STATE_END = 3 //for after a ball falls but before we go back to idle

ct U ARMS_LEFT = 0
ct U ARMS_MIDDLE = 1
ct U ARMS_RIGHT = 2

vars /vars_main
    //nesfab has a 'mode' syntax but I don't feel like messing with that right now.
    // see GAME_STATE_ consts for details
    U game_state = GAME_STATE_IDLE
    Bool fallen_ball_is_on_left = false //used for drawing the 'dropped ball' graphic when a game ends
    U game_end_timer = 0
    UU score = 0
    UU highscore_gamea = 0
    UU highscore_gameb = 0

    //Where player's arms are. See ARMS_ consts for details
    U arms_pos = ARMS_MIDDLE

    //written to PPUMASK and PPUCTRL at the start of each frame.
    U ppumask_mirror = (PPUMASK_ON | PPUMASK_NO_CLIP | PPUMASK_EMPHASIZE_R | PPUMASK_EMPHASIZE_G)
    U ppuctrl_mirror = (PPUCTRL_NT_2000 | PPUCTRL_NMI_ON)

fn init()
    {PPUMASK}(0)

    palette = main_palette
    ppu_upload_palette()

    //clear NT (including attribute table)
    ppu_set_addr($2000)
    for U y = 0; y < 31; y += 1
        for U x = 0; x < 64; x += 1
            {PPUDATA}($00)

    //Send screen data to NT
    ppu_set_addr($2000)
    ppu_upload_rlz(@main_tilemap)

    //make minor adjustments to attribute table to draw blue bars at top and bottom
    ppu_set_addr($23C0)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)

    ppu_set_addr($23F8)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    {PPUDATA}(%000000101)
    
    //hide sprites
    hide_oam(0)

    //Turn rendering back on
    {PPUMASK}(ppumask_mirror)
    {PPUCTRL}(ppuctrl_mirror)

nmi main_nmi()
    ppu_upload_oam_poll_pads(0)
    //disable rendering
    {PPUMASK}(0)

    update_sprites()
    if game_state == GAME_STATE_GAMEA || game_state == GAME_STATE_GAMEB
        draw_score()
    
    ppu_reset_scroll(0, 0)

    //re-enable rendering
    {PPUMASK}(ppumask_mirror)
    {PPUCTRL}(ppuctrl_mirror)

fn game_a_setup()
    arms_pos = ARMS_LEFT
    ball1.current_pos = 0
    ball1.going_left = false

    ball2.current_pos = 9
    ball2.going_left = true

    ball_timer = 0
    current_ball = 1
    score = 0

fn game_end(Bool on_left)
    if game_state == GAME_STATE_GAMEA && score > highscore_gamea
        highscore_gamea = score
    if game_state == GAME_STATE_GAMEB && score > highscore_gameb
        highscore_gameb = score
    game_state = GAME_STATE_END
    fallen_ball_is_on_left = on_left
    game_end_timer = 120

fn process_movement()
    if pads[0].pressed & BUTTON_LEFT
        if arms_pos == ARMS_RIGHT
            arms_pos = ARMS_MIDDLE
        else
            arms_pos = ARMS_LEFT
    if pads[0].pressed & BUTTON_RIGHT
        if arms_pos == ARMS_LEFT
            arms_pos = ARMS_MIDDLE
        else
            arms_pos = ARMS_RIGHT

fn draw_score()
    U[5] score_digits = uu_to_ddddd(score)

    //draw 4 digits of score without leading zeroes
    //TODO the number of if statements can be easily cut down. 
    //But will I bother before the deadline? Only time will tell.
    if score_digits[3] == 0
        draw_digit_at_offset(10,$20B6)
    else
        draw_digit_at_offset(score_digits[3],$20B6)
    if score_digits[2] == 0 && score_digits[3] == 0
        draw_digit_at_offset(10,$20B8)
    else
        draw_digit_at_offset(score_digits[2],$20B8)
    if score_digits[1] == 0 && score_digits[2] == 0 && score_digits[3] == 0
        draw_digit_at_offset(10,$20BA)
    else
        draw_digit_at_offset(score_digits[1],$20BA)

    draw_digit_at_offset(score_digits[0],$20BC)
    
    //draw_digit_at_offset(score_digits[4],$20B4)

fn draw_digit_at_offset(U digit, UU offset)
    ppu_set_addr(offset)
    {PPUDATA}(digits_tiles[digit].tile1)
    {PPUDATA}(digits_tiles[digit].tile2)
    ppu_set_addr(offset + $20)
    {PPUDATA}(digits_tiles[digit].tile3)
    {PPUDATA}(digits_tiles[digit].tile4)
    ppu_set_addr(offset + $40)
    {PPUDATA}(digits_tiles[digit].tile5)
    {PPUDATA}(digits_tiles[digit].tile6)


mode main()
: nmi main_nmi
    init()
    while true
        update_pads()

        switch game_state
            case GAME_STATE_IDLE
                //TODO clear score display
                //TODO clear dropped ball GFX
                //TODO if start is held but not released, draw high score
                //TODO if select is pressed, toggle between game A and game B

                if pads[0].released & BUTTON_START
                    game_a_setup()
                    game_state = GAME_STATE_GAMEA
                break
            case GAME_STATE_GAMEA
                process_movement()
                update_ball_state()
                
                break
            case GAME_STATE_GAMEB
                //TODO
                break
            case GAME_STATE_END
                process_movement()
                //TODO draw dropped ball graphix
                if game_end_timer == 0
                    game_state = GAME_STATE_IDLE
                else 
                    game_end_timer -= 1
                break
        nmi

chrrom
    file(fmt, "tileset.png")