//ball handling

ct Position[12] ball1_positions = Position[12](
    Position($30,$83),
    Position($34,$6F),
    Position($3C,$57),
    Position($48,$43),
    Position($58,$33),
    Position($6C,$27),
    Position($88,$27),
    Position($9C,$33),
    Position($AC,$43),
    Position($B8,$57),
    Position($C0,$6F),
    Position($C4,$83),
)
ct Position[12] ball2_positions = Position[12](
    Position($40,$7F),
    Position($44,$6B),
    Position($50,$57),
    Position($5C,$47),
    Position($70,$3B),
    Position($84,$3B),
    Position($98,$47),
    Position($A4,$57),
    Position($B0,$6B),
    Position($B4,$7F),
    Position($FF,$FF), //unused
    Position($FF,$FF) //unused
)
ct Position[12] ball3_positions = Position[12](
    Position($50,$7B),
    Position($54,$6B),
    Position($60,$5B),
    Position($70,$4F),
    Position($84,$4F),
    Position($94,$5B),
    Position($A0,$6B),
    Position($A4,$7B),
    Position($FF,$FF), //unused
    Position($FF,$FF), //unused
    Position($FF,$FF), //unused
    Position($FF,$FF) //unused
)

ct U BALL1_MAGIC_NUM = 11 //one less than the number of valid positions; the arr index of last valid position
ct U BALL2_MAGIC_NUM = 9
ct U BALL3_MAGIC_NUM = 7

struct Ball
    //balls have different numbers of positions, but we reserve 12 indices anyway. 
    //Somehow I doubt that Ball is RAM-heavy.
    Position[12] positions //not a spritedef because we don't need tile info - always the same for each ball
    U current_pos //$00-$0B are active positions; $FF is fall on left, $0C is fall on right; $FE is disabled
    U going_left

//for handling the gradual speedup as the game progresses
//Not sure what the best name for this is. It's very abstract.
struct Timing
    U speed
    UU points_thresh //The number of points scored before moving on to the next speed

ct Timing[8] game_a_timings = Timing[8](
    Timing(23, 5),
    Timing(19, 5),
    Timing(15, 10),
    Timing(14, 10),
    Timing(13, 20),
    Timing(12, 20),
    Timing(11, 10),
    Timing(10, 20)
)

ct Timing[12] game_b_timings = Timing[12](
    Timing(13, 200),
    Timing(12, 200),
    Timing(11, 100),
    Timing(10, 200),
    Timing(9, 200),
    Timing(8, 100),
    Timing(7, 200),
    Timing(6, 200),
    Timing(5, 100),
    Timing(4, 200),
    Timing(3, 200),
    Timing(2, 100)
)
vars /vars_ball

    //Ideally these would be in an array. However nesfab does not support arrays of structs that contain arrays. 
    //I think the 'correct' way to do this would be to have an array of pointers to Ball struct instances.
    //But I don't want to mess with pointers right now. Easier in the short term to just copy-paste ball code
    Ball ball1 = Ball(ball1_positions, 0, false)
    Ball ball2 = Ball(ball2_positions, 0, true)
    Ball ball3 = Ball(ball3_positions, 0, false)

    U ball_timer = 0
    U current_ball = 1
    UU speedup_thresh = 0
    U timings_index = 0

fn game_a_setup()
    arms_pos = ARMS_LEFT

    ball1.current_pos = 0
    ball1.going_left = false

    ball2.current_pos = 9
    ball2.going_left = true

    ball3.current_pos = 11 //hide it
    ball3.going_left = true

    ball_timer = 0
    current_ball = 1
    
    score = 0
    timings_index = 0
    speedup_thresh = game_a_timings[timings_index].points_thresh

fn game_b_setup()
    arms_pos = ARMS_LEFT

    ball1.current_pos = 0
    ball1.going_left = false

    ball2.current_pos = 9
    ball2.going_left = true

    ball3.current_pos = 0
    ball3.going_left = false

    ball_timer = 0
    current_ball = 1
    
    score = 0
    timings_index = 0
    speedup_thresh = game_b_timings[timings_index].points_thresh

fn update_balls()
    //increment ball timer
    //There is almost definitely a cleaner way to handle values wrapping around. But this is good enough.
    if ball_timer == 0
        if game_state == GAME_STATE_GAMEA
            ball_timer = game_a_timings[timings_index].speed
        else
            ball_timer = game_b_timings[timings_index].speed
    else
        ball_timer -= 1

    //silence any prevous sfx
    //They are all supposed to be only 1 frame long and this seemed like the easiest way.
    {$4000}(%00010000)
    {$4004}(%00010000)

        //If ball is at either lowest point, heading down, and hand is under it, change ball direction
    if ball1.current_pos == 0 && arms_pos == ARMS_LEFT && ball1.going_left == true
        ball1.going_left = false
        ball_hit_react()
    else if ball1.current_pos == BALL1_MAGIC_NUM && arms_pos == ARMS_RIGHT && ball1.going_left == false
        ball1.going_left = true
        ball_hit_react()

    if ball2.current_pos == 0 && arms_pos == ARMS_MIDDLE && ball2.going_left == true
        ball2.going_left = false
        ball_hit_react()
    else if ball2.current_pos == BALL2_MAGIC_NUM && arms_pos == ARMS_MIDDLE && ball2.going_left == false
        ball2.going_left = true
        ball_hit_react()

    if ball3.current_pos == 0 && arms_pos == ARMS_RIGHT && ball3.going_left == true
        ball3.going_left = false
        ball_hit_react()
    else if ball3.current_pos == BALL3_MAGIC_NUM && arms_pos == ARMS_LEFT && ball3.going_left == false
        ball3.going_left = true
        ball_hit_react()


    //maybe update current_ball. will go 1,2,1,2... in game a, and 1,2,3,1,2,3... in game b
    if ball_timer == 0
        current_ball += 1
        if current_ball == game_state + 2 
            current_ball = 1
    
        //update the current ball's position.
        //This is one area that would be a lot cleaner if we had an array of balls
        switch current_ball  
            case 1
                //move ball
                if ball1.going_left
                    if ball1.current_pos == $00
                        game_end(true) //game ended with dropped ball on left      
                    else
                        ball1.current_pos -= 1
                else
                    if ball1.current_pos == BALL1_MAGIC_NUM
                        game_end(false) //game ended with dropped ball on right 
                    else 
                        ball1.current_pos += 1     
                //play sound on channel 1
                //https://www.nesdev.org/wiki/APU#Pulse_($4000%E2%80%93$4007)
                {$4000}(%10011011)
                {$4002}($35)
                {$4003}(%00000000)                
                break
            case 2
                //move ball
                if ball2.going_left
                    if ball2.current_pos == $00
                        game_end(true) //game ended with dropped ball on left      
                    else
                        ball2.current_pos -= 1
                else
                    if ball2.current_pos == BALL2_MAGIC_NUM
                        game_end(false) //game ended with dropped ball on right 
                    else 
                        ball2.current_pos += 1     
                //play sound on channel 1
                //https://www.nesdev.org/wiki/APU#Pulse_($4000%E2%80%93$4007)
                {$4000}(%01011101)
                {$4002}($57)
                {$4003}(%00000000) 
                break
            case 3
                //move ball
                if ball3.going_left
                    if ball3.current_pos == $00
                        game_end(true) //game ended with dropped ball on left      
                    else
                        ball3.current_pos -= 1
                else
                    if ball3.current_pos == BALL3_MAGIC_NUM
                        game_end(false) //game ended with dropped ball on right 
                    else 
                        ball3.current_pos += 1     
                //play sound on channel 1
                //https://www.nesdev.org/wiki/APU#Pulse_($4000%E2%80%93$4007)
                {$4000}(%01011101)
                {$4002}($46)
                {$4003}(%00000000) 
                break
                

fn ball_hit_react()
    //play sound on channel 2
    //https://www.nesdev.org/wiki/APU#Pulse_($4000%E2%80%93$4007)
    {$4004}(%1001111)
    {$4006}($6C)
    {$4007}($00000000) 

    if game_state == GAME_STATE_GAMEA
        score += 1
        speedup_thresh -= 1
        if speedup_thresh == 0
            timings_index += 1
            if timings_index == len(game_a_timings)
                timings_index = 0
            speedup_thresh = game_a_timings[timings_index].points_thresh
    else 
        score += 10
        speedup_thresh -= 10
        if speedup_thresh == 0
            timings_index += 1
            if timings_index == len(game_b_timings)
                timings_index = 0
            speedup_thresh = game_b_timings[timings_index].points_thresh
