//ball handling

//TODO un-placeholderize these
ct Position[12] ball1_positions = Position[12](
    Position($30,$83),
    Position($34,$6F),
    Position($3C,$57),
    Position($48,$43),
    Position($58,$33),
    Position($6C,$27),
    Position($88,$27),
    Position($9C,$33),
    Position($AC,$43),
    Position($B8,$57),
    Position($C0,$6F),
    Position($C4,$83),
)
ct Position[12] ball2_positions = Position[12](
    Position(0,20),
    Position(10,70),
    Position(20,70),
    Position(30,70),
    Position(40,70),
    Position(50,70),
    Position(60,70),
    Position(70,70),
    Position(80,70),
    Position(90,70),
    Position($FF,$FF), //unused
    Position($FF,$FF) //unused
)
ct Position[12] ball3_positions = Position[12](
    Position($FF,$FF),
    Position($FF,$FF),
    Position($FF,$FF),
    Position($FF,$FF),
    Position($FF,$FF),
    Position($FF,$FF),
    Position($FF,$FF),
    Position($FF,$FF),
    Position($FF,$FF), //unused
    Position($FF,$FF), //unused
    Position($FF,$FF), //unused
    Position($FF,$FF) //unused
)

ct U BALL_POS_DISABLED = 12

struct Ball
    //balls have different numbers of positions, but we reserve 12 indices anyway. 
    //Somehow I doubt that Ball is RAM-heavy.
    Position[12] positions //not a spritedef because we don't need tile info - always the same for each ball
    U pos_count //ball 1 has 12 positions, ball 2 has 10, ball 3 has 8
    U current_pos //$00-$0B are active positions; $FF is fall on left, $0C is fall on right; $FE is disabled
    U going_left

vars /vars_ball

    //Ideally these would be in an array. However nesfab does not support arrays of structs that contain arrays. 
    //I think the 'correct' way to do this would be to have an array of pointers to Ball struct instances.
    //But I don't want to mess with pointers right now. Easier in the short term to just copy-paste ball code
    Ball ball1 = Ball(ball1_positions, 12, BALL_POS_DISABLED, false)
    Ball ball2 = Ball(ball2_positions, 10, BALL_POS_DISABLED, true)
    Ball ball3 = Ball(ball3_positions, 8, BALL_POS_DISABLED, false)

    U ball_timer = 0
    U current_ball = 1


fn update_ball_state()
    //If ball is at either lowest point, and hand is under it, change ball direction
    if ball1.current_pos == 0 && arms_pos == ARMS_LEFT
        ball1.going_left = false
        //TODO play ball hit sfx
    else if ball1.current_pos == 11 && arms_pos == ARMS_RIGHT
        ball1.going_left = true
        //TODO play ball hit sfx

    //TODO ball 2 and 3 collision

    //increment ball timer
    //There is almost definitely a cleaner way to handle values wrapping around. But this is good enough.
    if ball_timer == 0
        ball_timer = 20
    else
        ball_timer -= 1

    //maybe update current_ball. will go 1,2,1,2... in game a, and 1,2,3,1,2,3... in game b
    if ball_timer == 0
        current_ball += 1
        if current_ball == game_state + 2 
            current_ball = 1
    
        //update the current ball's position.
        //This is one area that would be a lot cleaner if we had an array of balls
        switch current_ball  
            case 1
                //move ball
                if ball1.going_left
                    if ball1.current_pos == $00
                        game_end(true) //game ended with dropped ball on left      
                    else
                        ball1.current_pos -= 1
                else
                    if ball1.current_pos == 11
                        game_end(false) //game ended with dropped ball on right 
                    else 
                        ball1.current_pos += 1                     
                break
            case 2
                //move ball
                // if ball2.going_left
                //     ball2.current_pos -= 1
                // else
                //     ball2.current_pos += 1
                //TODO
                break
            case 3
                break
